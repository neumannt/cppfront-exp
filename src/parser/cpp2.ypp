%skeleton "lalr1.cc"
%require "3.0"
%define api.namespace {cpp2exp::parser}
%define api.value.type {cpp2exp::AST*}
%define parse.error verbose

%lex-param { cpp2exp::ASTContainer& container }
%lex-param { cpp2exp::Lexer& lexer }
%parse-param { cpp2exp::ASTContainer& container }
%parse-param { cpp2exp::Lexer& lexer }

%code requires{
#include "parser/Lexer.hpp"
#include "parser/Parser.hpp"
#include "parser/AST.hpp"
}
%code{
static int yylex(cpp2exp::parser::parser::semantic_type* yylval, cpp2exp::ASTContainer& container, cpp2exp::Lexer& lexer);
}


// Lexer tokens
%token EndOfFile 0 "end-of-file"
%token Error
%token AMPERSAND "'&'"
%token AMPERSANDEQ "'&='"
%token ARROW "'->'"
%token ASSIGNMENT "'='"
%token BINARYLITERAL "<binaryliteral>"
%token CARET "'^'"
%token CARETEQ "'^='"
%token CHARACTERLITERAL "<characterliteral>"
%token COLON "':'"
%token COMMA "','"
%token DECIMALLITERAL "<decimalliteral>"
%token DOLLAR "'$'"
%token DOT "'.'"
%token ELLIPSIS "'...'"
%token EQUALCOMPARISON "'=='"
%token FLOATLITERAL "<floatliteral>"
%token GREATER "'>'"
%token GREATEREQ "'>='"
%token HEXADECIMALLITERAL "<hexliteral>"
%token IDENTIFIER "'<identifier>'"
%token LEFTBRACE "'{'"
%token LEFTBRACKET "'['"
%token LEFTPAREN "'('"
%token LEFTSHIFT "'<<'"
%token LEFTSHIFTEQ "'<<='"
%token LESS "'<'"
%token LESSEQ "'<='"
%token LOGICALAND "'&&'"
%token LOGICALANDEQ "'&&='"
%token LOGICALOR "'||'"
%token LOGICALOREQ "'||='"
%token MINUS "'-'"
%token MINUSEQ "'-='"
%token MINUSMINUS "'--'"
%token MODULO "'%'"
%token MODULOEQ "'%='"
%token MULTIPLY "'*'"
%token MULTIPLYEQ "'*='"
%token NOT "'!'"
%token NOTEQUALCOMPARISON "'!='"
%token OCTALLITERAL "<octalliteral>"
%token PIPE "'|'"
%token PIPEEQ "'|='"
%token PLUS "'+'"
%token PLUSEQ "'+='"
%token PLUSPLUS "'++'"
%token POSTFIXAMPERSAND
%token POSTFIXMULTIPLY
%token QUESTIONMARK "'?'"
%token RIGHTBRACE "'}'"
%token RIGHTBRACKET "']'"
%token RIGHTPAREN "')'"
%token RIGHTSHIFT "'>>'"
%token RIGHTSHIFTEQ "'>>='"
%token SCOPE "'::'"
%token SEMICOLON "';'"
%token SLASH "'/'"
%token SLASHEQ "'/='"
%token SPACESHIP "'<=>'"
%token STRINGLITERAL "<stringliteral>"
%token TILDE "'~'"
%token TILDEEQ "'~='"

// Keywords
%token ALIGNAS "alignas"
%token ALIGNOF "alignof"
%token ASM "asm"
%token AS "as"
%token AUTO "auto"
%token BOOL "bool"
%token BREAK "break"
%token CASE "case"
%token CATCH "catch"
%token CHAR "char"
%token CHAR16_T "char16_t"
%token CHAR32_T "char32_t"
%token CHAR8_T "char8_t"
%token CLASS "class"
%token CO_AWAIT "co_await"
%token CO_RETURN "co_return"
%token CO_YIELD "co_yield"
%token CONCEPT "concept"
%token CONST "const"
%token CONST_CAST "const_cast"
%token CONSTEVAL "consteval"
%token CONSTEXPR "constexpr"
%token CONSTINIT "constinit"
%token CONTINUE "continue"
%token DELETE "delete"
%token DECLTYPE "decltype"
%token DEFAULT "default"
%token DOUBLE "double"
%token DO "do"
%token DYNAMIC_CAST "dynamic_cast"
%token ELSE "else"
%token ENUM "enum"
%token EXPLICIT "explicit"
%token EXPORT "export"
%token EXTERN "extern"
%token FALSE "false"
%token FLOAT "float"
%token FOR "for"
%token FRIEND "friend"
%token GOTO "goto"
%token IF "if"
%token IMPORT "import"
%token INLINE "inline"
%token INSPECT "inspect"
%token INT "int"
%token IS "is"
%token LONG "long"
%token MODULE "module"
%token MUTABLE "mutable"
%token NAMESPACE "namespace"
%token NEW "new"
%token NOEXCEPT "noexcept"
%token NULLPTR "nullptr"
%token OPERATOR "operator"
%token PRIVATE "private"
%token PROTECTED "protected"
%token PUBLIC "public"
%token REGISTER "register"
%token REINTERPRET_CAST "reinterpret_cast"
%token REQUIRES "requires"
%token RETURN "return"
%token SHORT "short"
%token SIGNED "signed"
%token SIZEOF "sizeof"
%token STATIC "static"
%token STATIC_ASSERT "static_assert"
%token STATIC_CAST "static_cast"
%token STRUCT "struct"
%token SWITCH "switch"
%token TEMPLATE "template"
%token THIS "this"
%token THREAD_LOCAL "thread_local"
%token THROWS "throws"
%token THROW "throw"
%token TRUE "true"
%token TRY "try"
%token TYPEDEF "typedef"
%token TYPEID "typeid"
%token TYPENAME "typename"
%token UNION "union"
%token UNSIGNED "unsigned"
%token USING "using"
%token VIRTUAL "virtual"
%token VOID "void"
%token VOLATILE "volatile"
%token WCHAR_T "wchar_t"
%token WHILE "while"

// Softkeywords
%token PRE "pre"
%token POST "post"
%token ASSERT "assert"
%token IN "in"
%token COPY "copy"
%token INOUT "inout"
%token OUT "out"
%token MOVE "move"
%token FORWARD "forward"
%token LET "let"
%token NEXT "next"

%%

translation-unit:
   declaration-seq { container.setResult($$ = ast::TranslationUnit::build(container, $1)); }
 | %empty { container.setResult($$ = ast::TranslationUnit::build(container, nullptr)); }
;

SOFTKEYWORD: PRE | POST | ASSERT | IN | COPY | INOUT | OUT | MOVE | FORWARD | LET | NEXT;

identifier:
   IDENTIFIER
 | SOFTKEYWORD
;
string-literal: STRINGLITERAL;

parameter-declaration-list:
   LEFTPAREN parameter-declaration-seq-opt RIGHTPAREN { $$ = ast::ParameterDeclarationList::build(container, $1); }
;

parameter-declaration-seq:
   parameter-declaration { $$ = ast::ParameterDeclarationSeq::build(container, $1); }
 | parameter-declaration-seq COMMA parameter-declaration { $$ = ast::ParameterDeclarationSeq::append(container, $1, $2); }
;

parameter-declaration-seq-opt:
   parameter-declaration-seq
 | %empty { $$ = nullptr; }
;

parameter-declaration:
   parameter-direction declaration { $$ = ast::ParameterDeclaration::build(container, $1, $2); }
 | declaration { $$ = ast::ParameterDeclaration::build(container, nullptr, $1); }
;

parameter-direction:
   IN
 | COPY
 | INOUT
 | OUT
 | MOVE
 | FORWARD
;

function-type:
   parameter-declaration-list throws-specifier-opt return-list-opt contract-seq-opt { $$ = ast::FunctionType::build(container, $1, $2, $3, $4); }
;

throws-specifier-opt:
   THROWS
 | %empty { $$ = nullptr; }
;

return-list-opt:
   id-expression { $$ = ast::ReturnList::build(container, ast::ReturnList::Single, $1); }
 | parameter-declaration-list { $$ = ast::ReturnList::build(container, ast::ReturnList::Multiple, $1); }
 | %empty { $$ = nullptr; }
;

contract:
   LEFTBRACKET LEFTBRACKET contract-kind id-expression-opt COLON logical-or-expression RIGHTBRACKET RIGHTBRACKET { $$ = ast::Contract::build(container, $3, $4, $6, nullptr); }
 | LEFTBRACKET LEFTBRACKET contract-kind id-expression-opt COLON logical-or-expression COMMA string-literal RIGHTBRACKET RIGHTBRACKET { $$ = ast::Contract::build(container, $3, $4, $6, $8); }
;

contract-kind:
   PRE
 | POST
 | ASSERT
;

contract-seq:
   contract { $$ = ast::ContractSeq::build(container, $1); }
 | contract-seq contract { $$ = ast::ContractSeq::append(container, $1, $2); }
;

contract-seq-opt:
   contract-seq
 | %empty { $$ = nullptr; }
;


unnamed-declaration:
   COLON function-type ASSIGNMENT statement { $$ = ast::UnnamedDeclaration::build(container, ast::UnnamedDeclaration::Function, $2, $4); }
 | COLON id-expression-opt ASSIGNMENT statement { $$ = ast::UnnamedDeclaration::build(container, ast::UnnamedDeclaration::Value, $2, $4); }
 | COLON id-expression { $$ = ast::UnnamedDeclaration::build(container, ast::UnnamedDeclaration::Value, $2, nullptr); }
;

unqualified-id:
   const-opt identifier { $$ = ast::UnqualifiedId::build(container, ast::UnqualifiedId::Normal, $1, $2); }
 | const-opt template-id { $$ = ast::UnqualifiedId::build(container, ast::UnqualifiedId::Template, $1, $2); }
;

const-opt:
   CONST
 | %empty { $$ = nullptr; }
;

template-id:
   identifier NOT LEFTBRACKET template-argument-list-opt RIGHTBRACKET { $$ = ast::TemplateId::build(container, $1, $3); }
;

template-argument-list:
   template-argument { $$ = ast::TemplateArgumentList::build(container, $1); }
 | template-argument-list COMMA template-argument { $$ = ast::TemplateArgumentList::append($1, $3); }
;

template-argument-list-opt:
   template-argument-list
 | %empty { $$ = nullptr; }
;

template-argument:
   expression { $$ = ast::TemplateArgument::build(container, ast::TemplateArgument::Expression, $1); }
 // TODO | id-expression { $$ = ast::TemplateArgument::build(container, ast::TemplateArgument::IdExpression, $1); }
;


qualified-id:
   nested-name-specifier unqualified-id { $$ = ast::QualifiedId::build(container, ast::QualifiedId::Nested, $1, $2); }
 | member-name-specifier unqualified-id { $$ = ast::QualifiedId::build(container, ast::QualifiedId::Member, $1, $2); }
;
qualified-id-after-dot:
   nested-name-specifier unqualified-id { $$ = ast::QualifiedId::build(container, ast::QualifiedId::Nested, $1, $2); }
;

nested-name-specifier:
   SCOPE { $$ = nullptr; }
 | unqualified-id SCOPE { $$ = $1; }
;

member-name-specifier:
   unqualified-id DOT { $$ = $1; }
;

id-expression:
   unqualified-id
 | qualified-id
;
id-expression-after-dot:
   unqualified-id
 | qualified-id-after-dot
;


id-expression-opt:
   id-expression
 | %empty { $$ = nullptr; }
;

declaration:
   identifier unnamed-declaration { $$ = ast::Declaration::build(container, $1, $2); }
;

declaration-seq:
   declaration SEMICOLON { $$ = ast::DeclarationSeq::build(container, $1); }
 | declaration-seq declaration SEMICOLON { $$ = ast::DeclarationSeq::append(container, $1, $2); }
;

expression:
   assignment-expression
;

expression-list:
   expression { $$ = ast::ExpressionList::build(container, $1); }
 | expression-list COMMA expression { $$ = ast::ExpressionList::append(container, $1, $3); }
;

assignment-expression:
   logical-or-expression
 | logical-or-expression assignment-operator assignment-expression { $$ = ast::AssignmentExpression::build(container, $1, $2, $3); }
;

assignment-operator:
   ASSIGNMENT
 | MULTIPLYEQ
 | SLASHEQ
 | MODULOEQ
 | PLUSEQ
 | MINUSEQ
 | RIGHTSHIFTEQ
 | LEFTSHIFTEQ
 | AMPERSANDEQ
 | CARETEQ
 | PIPEEQ
;

logical-or-expression:
   logical-and-expression
 | logical-or-expression LOGICALOR logical-and-expression { $$ = ast::BinaryExpression::build(container, BinaryExpression::LogicalOr, $1, $3); }
;

logical-and-expression:
   bit-or-expression
 | logical-and-expression LOGICALAND bit-or-expression { $$ = ast::BinaryExpression::build(container, BinaryExpression::LogicalAnd, $1, $3); }
;

bit-or-expression:
   bit-xor-expression
 | bit-or-expression PIPE bit-xor-expression { $$ = ast::BinaryExpression::build(container, BinaryExpression::BitOr, $1, $3); }
;

bit-xor-expression:
   bit-and-expression
 | bit-xor-expression CARET bit-and-expression { $$ = ast::BinaryExpression::build(container, BinaryExpression::BitXor, $1, $3); }
;

bit-and-expression:
   equality-expression
 | bit-and-expression AMPERSAND equality-expression { $$ = ast::BinaryExpression::build(container, BinaryExpression::BitAnd, $1, $3); }
;

equality-expression:
   relational-expression
 | equality-expression EQUALCOMPARISON relational-expression { $$ = ast::BinaryExpression::build(container, BinaryExpression::Equal, $1, $3); }
 | equality-expression NOTEQUALCOMPARISON relational-expression { $$ = ast::BinaryExpression::build(container, BinaryExpression::NotEqual, $1, $3); }
;

relational-expression:
   compare-expression
 | relational-expression LESS compare-expression { $$ = ast::BinaryExpression::build(container, BinaryExpression::Less, $1, $3); }
 | relational-expression GREATER compare-expression { $$ = ast::BinaryExpression::build(container, BinaryExpression::Greater, $1, $3); }
 | relational-expression LESSEQ compare-expression { $$ = ast::BinaryExpression::build(container, BinaryExpression::LessEq, $1, $3); }
 | relational-expression GREATEREQ compare-expression { $$ = ast::BinaryExpression::build(container, BinaryExpression::GreaterEq, $1, $3); }
;

compare-expression:
   shift-expression
 | compare-expression SPACESHIP shift-expression { $$ = ast::BinaryExpression::build(container, BinaryExpression::Spaceship, $1, $3); }
;

shift-expression:
   additive-expression
 | shift-expression LEFTSHIFT additive-expression { $$ = ast::BinaryExpression::build(container, BinaryExpression::LeftShift, $1, $3); }
 | shift-expression RIGHTSHIFT additive-expression { $$ = ast::BinaryExpression::build(container, BinaryExpression::RightShift, $1, $3); }
;

additive-expression:
   multiplicative-expression
 | additive-expression PLUS multiplicative-expression { $$ = ast::BinaryExpression::build(container, BinaryExpression::Plus, $1, $3); }
 | additive-expression MINUS multiplicative-expression { $$ = ast::BinaryExpression::build(container, BinaryExpression::Minus, $1, $3); }
;

multiplicative-expression:
   is-as-expression
 | multiplicative-expression MULTIPLY is-as-expression { $$ = ast::BinaryExpression::build(container, BinaryExpression::Mul, $1, $3); }
 | multiplicative-expression SLASH is-as-expression { $$ = ast::BinaryExpression::build(container, BinaryExpression::Div, $1, $3); }
 | multiplicative-expression MODULO is-as-expression { $$ = ast::BinaryExpression::build(container, BinaryExpression::Modulo, $1, $3); }
;

is-as-expression:
   prefix-expression
;

prefix-expression:
   postfix-expression
 | prefix-operator prefix-expression { $$ = ast::PrefixExpression::build(container, $1, $2); }
;

prefix-operator:
   NOT
 | PLUS
 | MINUS
;

postfix-expression:
   primary-expression
 | postfix-expression PLUSPLUS { $$ = ast::PostfixExpression::build(container, $1, $2); }
 | postfix-expression MINUSMINUS { $$ = ast::PostfixExpression::build(container, $1, $2); }
 | postfix-expression POSTFIXMULTIPLY { $$ = ast::PostfixExpression::build(container, $1, $2); }
 | postfix-expression POSTFIXAMPERSAND { $$ = ast::PostfixExpression::build(container, $1, $2); }
 | postfix-expression TILDE { $$ = ast::PostfixExpression::build(container, $1, $2); }
 | postfix-expression DOLLAR { $$ = ast::PostfixExpression::build(container, $1, $2); }
 | postfix-expression LEFTBRACKET expression-list RIGHTBRACKET { $$ = ast::BracketExpression::build(container, $1, $2); }
 | postfix-expression LEFTPAREN expression-list RIGHTPAREN { $$ = ast::ParenExpression::build(container, $1, $2); }
 | postfix-expression LEFTPAREN RIGHTPAREN { $$ = ast::ParenExpression::build(container, $1, nullptr); }
 | postfix-expression DOT id-expression-after-dot { $$ = ast::DotExpression::build(container, $1, $2); }
;

primary-expression:
   literal
 | LEFTPAREN expression-list RIGHTPAREN { $$ = $2; }
// TODO | id-expression-after-dot
 | unnamed-declaration SEMICOLON
// TODO | inspect-expression
;

literal:
   identifier { $$ = ast::Literal::build(container, ast::Literal::Identifier, $1); }
 | DECIMALLITERAL { $$ = ast::Literal::build(container, ast::Literal::Decimal, $1); }
 | FLOATLITERAL { $$ = ast::Literal::build(container, ast::Literal::Float, $1); }
 | STRINGLITERAL { $$ = ast::Literal::build(container, ast::Literal::String, $1); }
 | CHARACTERLITERAL { $$ = ast::Literal::build(container, ast::Literal::Char, $1); }
 | BINARYLITERAL { $$ = ast::Literal::build(container, ast::Literal::Binary, $1); }
 | OCTALLITERAL { $$ = ast::Literal::build(container, ast::Literal::Octal, $1); }
 | HEXADECIMALLITERAL { $$ = ast::Literal::build(container, ast::Literal::Hex, $1); }
;

statement:
   expression-statement
 | compound-statement
 | selection-statement
 | declaration-statement
 | return-statement
 | iteration-statement
 | inspect-expression
 // TODO | LET LEFTPAREN parameter-declaration-list statement { $$ = ast::Let::build(container, $2, $3); }
;

expression-statement:
   expression SEMICOLON { $$ = ast::ExpressionStatement::build(container, $1); }
;

compound-statement:
   LEFTBRACE statement-seq RIGHTBRACE { $$ = ast::CompoundStatement::build(container, $2); }
 | LEFTBRACE RIGHTBRACE { $$ = ast::CompoundStatement::build(container, $2); }
;

statement-seq:
   statement { $$ = ast::StatementSeq::build($1); }
 | statement-seq statement { $$ = ast::StatementSeq::append($1, $2); }
;

selection-statement:
   IF constexpr-opt expression compound-statement { $$ = ast::SelectStatement::build(container, $2, $3, $4); }
 | IF constexpr-opt expression compound-statement ELSE compound-statement { $$ = ast::SelectStatement::build(container, $2, $3, $4, $5); }
;

constexpr-opt:
   CONSTEXPR
 | %empty { $$ = nullptr; }
;

declaration-statement:
   declaration SEMICOLON { $$ = ast::DeclarationStatement::build(container, $1); }
;

return-statement:
   RETURN SEMICOLON { $$ = ast::ReturnStatement::build(container, nullptr); }
 | RETURN expression SEMICOLON { $$ = ast::ReturnStatement::build(container, $2); }
;

iteration-statement:
   WHILE logical-or-expression next-clause-opt compound-statement { $$ = ast::WhileStatement::build(container, $2, $3, $4); }
 | DO compound-statement WHILE logical-or-expression next-clause-opt SEMICOLON { $$ = ast::DoWhileStatement::build(container, $2, $4, $5); }
 | FOR expression next-clause-opt DO unnamed-declaration SEMICOLON { $$ = ast::ForStatement::build(container, $2, $3, $5); }
;

next-clause-opt:
   NEXT assignment-expression { $$ = $2; }
 | %empty { $$ = nullptr; }
;

inspect-expression:
   INSPECT constexpr-opt expression LEFTBRACE alternative-seq-opt RIGHTBRACE { $$ = ast::InspectExpression::build(container, $2, $3, nullptr, $5); }
 | INSPECT constexpr-opt expression ARROW id-expression LEFTBRACE alternative-seq-opt RIGHTBRACE { $$ = ast::InspectExpression::build(container, $2, $3, $5, $7); }
;

alternative-seq:
   alternative { $$ = ast::AlternativeSeq::build($1); }
 | alternative-seq alternative { $$ = ast::AlternativeSeq::append($1, $2); }
;

alternative-seq-opt:
   alternative-seq
 | %empty { $$ = nullptr; }
;

alternative:
   alt-name-opt is-type-constraint ASSIGNMENT statement { $$ = ast::Alternative::build(container, ast::Alterantive::Is, $1, $2, $4); }
 | alt-name-opt as-type-cast ASSIGNMENT statement { $$ = ast::Alternative::build(container, ast::Alterantive::As, $1, $2, $4); }
;

alt-name: unqualified-id COLON;
alt-name-opt:
   alt-name
 | %empty { $$ = nullptr; }
;

is-type-constraint:
   IS id-expression { $$ = $2; }
;

as-type-cast:
   AS id-expression { $$ = $2; }
;

%%

namespace cpp2exp { namespace parser {

void parser::error(const std::string& s) {
   lexer.addParseError(s);
}

}}

// All non-keyword Lexer tokens and their corresponding bison tokens
#define LEXER_TOKENS(X) \
   X(Eof, EndOfFile) X(Error, Error) X(Ampersand, AMPERSAND) X(AmpersandEq, AMPERSANDEQ) X(Arrow, ARROW) X(Assignment, ASSIGNMENT) X(BinaryLiteral, BINARYLITERAL) X(Caret, CARET) \
   X(CaretEq, CARETEQ) X(CharacterLiteral, CHARACTERLITERAL) X(Colon, COLON) X(Comma, COMMA) X(DecimalLiteral, DECIMALLITERAL) X(Dollar, DOLLAR) X(Dot, DOT) X(Ellipsis, ELLIPSIS) \
   X(EqualComparison, EQUALCOMPARISON) X(FloatLiteral, FLOATLITERAL) X(Greater, GREATER) X(GreaterEq, GREATEREQ) X(HexadecimalLiteral, HEXADECIMALLITERAL) X(Identifier, IDENTIFIER) \
   X(LeftBrace, LEFTBRACE) X(LeftBracket, LEFTBRACKET) X(LeftParen, LEFTPAREN) X(LeftShift, LEFTSHIFT) X(LeftShiftEq, LEFTSHIFTEQ) X(Less, LESS) X(LessEq, LESSEQ) \
   X(LogicalAnd, LOGICALAND) X(LogicalAndEq, LOGICALANDEQ) X(LogicalOr, LOGICALOR) X(LogicalOrEq, LOGICALOREQ) X(Minus, MINUS) X(MinusEq, MINUSEQ) X(MinusMinus, MINUSMINUS) \
   X(Modulo, MODULO) X(ModuloEq, MODULOEQ) X(Multiply, MULTIPLY) X(MultiplyEq, MULTIPLYEQ) X(Not, NOT) X(NotEqualComparison, NOTEQUALCOMPARISON) X(OctalLiteral, OCTALLITERAL) \
   X(Pipe, PIPE) X(PipeEq, PIPEEQ) X(Plus, PLUS) X(PlusEq, PLUSEQ) X(PlusPlus, PLUSPLUS) X(PostfixAmpersand, POSTFIXAMPERSAND) X(PostfixMultiply, POSTFIXMULTIPLY) \
   X(QuestionMark, QUESTIONMARK) X(RightBrace, RIGHTBRACE) X(RightBracket, RIGHTBRACKET) \
   X(RightParen, RIGHTPAREN) X(RightShift, RIGHTSHIFT) X(RightShiftEq, RIGHTSHIFTEQ) X(Scope, SCOPE) X(Semicolon, SEMICOLON) X(Slash, SLASH) X(SlashEq, SLASHEQ) \
   X(Spaceship, SPACESHIP) X(StringLiteral, STRINGLITERAL) X(Tilde, TILDE) X(TildeEq, TILDEEQ)

// All keyword tokens and their corresponding bison tokens
#define LEXER_KEYWORDS(X) \
   X(Alignas, ALIGNAS) X(Alignof, ALIGNOF) X(Asm, ASM) X(As, AS) X(Auto, AUTO) X(Bool, BOOL) X(Break, BREAK) X(Case, CASE) X(Catch, CATCH) X(Char, CHAR) X(Char16_t, CHAR16_T) \
   X(Char32_t, CHAR32_T) X(Char8_t, CHAR8_T) X(Class, CLASS) X(Co_await, CO_AWAIT) X(Co_return, CO_RETURN) X(Co_yield, CO_YIELD) X(Concept, CONCEPT) X(Const, CONST) \
   X(Const_cast, CONST_CAST) X(Consteval, CONSTEVAL) X(Constexpr, CONSTEXPR) X(Constinit, CONSTINIT) X(Continue, CONTINUE) X(Delete, DELETE) X(Decltype, DECLTYPE) X(Default, DEFAULT) X(Double, DOUBLE) \
   X(Do, DO) X(Dynamic_cast, DYNAMIC_CAST) X(Else, ELSE) X(Enum, ENUM) X(Explicit, EXPLICIT) X(Export, EXPORT) X(Extern, EXTERN) X(False, FALSE) X(Float, FLOAT) X(For, FOR) \
   X(Friend, FRIEND) X(Goto, GOTO) X(If, IF) X(Import, IMPORT) X(Inline, INLINE) X(Inspect, INSPECT) X(Int, INT) X(Is, IS) X(Long, LONG) X(Module, MODULE) X(Mutable, MUTABLE) X(Namespace, NAMESPACE) \
   X(New, NEW) X(Noexcept, NOEXCEPT) X(Nullptr, NULLPTR) X(Operator, OPERATOR) X(Private, PRIVATE) X(Protected, PROTECTED) X(Public, PUBLIC) X(Register, REGISTER) \
   X(Reinterpret_cast, REINTERPRET_CAST) X(Requires, REQUIRES) X(Return, RETURN) X(Short, SHORT) X(Signed, SIGNED) X(Sizeof, SIZEOF) X(Static, STATIC) X(Static_assert, STATIC_ASSERT) \
   X(Static_cast, STATIC_CAST) X(Struct, STRUCT) X(Switch, SWITCH) X(Template, TEMPLATE) X(This, THIS) X(Thread_local, THREAD_LOCAL) X(Throws, THROWS) X(Throw, THROW) X(True, TRUE) \
   X(Try, TRY) X(Typedef, TYPEDEF) X(Typeid, TYPEID) X(Typename, TYPENAME) X(Union, UNION) X(Unsigned, UNSIGNED) X(Using, USING) X(Virtual, VIRTUAL) X(Void, VOID) \
   X(Volatile, VOLATILE) X(Wchar_t, WCHAR_T) X(While, WHILE) \
   X(Pre, PRE) X(Post, POST) X(Assert, ASSERT) X(In, IN) X(Copy, COPY) X(Inout, INOUT) X(Out, OUT) X(Move, MOVE) X(Forward, FORWARD) X(Let, LET) X(Next, NEXT)

// The mapping table from Lexer tokens to bison tokens
static constexpr cpp2exp::parser::parser::token::yytokentype tokenTable[]={
#define A(X,Y) cpp2exp::parser::parser::token::Y,
LEXER_TOKENS(A)
LEXER_KEYWORDS(A)
#undef A
};

// Verify that the mapping table is correct
#define A(X,Y) static_assert(tokenTable[static_cast<unsigned>(cpp2exp::Lexer::Token::X)]==cpp2exp::parser::parser::token::Y,"incorrect token mapping");
LEXER_TOKENS(A)
#undef A
#define A(X,Y) static_assert(tokenTable[static_cast<unsigned>(cpp2exp::Lexer::Token::Keyword) + static_cast<unsigned>(cpp2exp::Lexer::Keyword::X)]==cpp2exp::parser::parser::token::Y,"incorrect keyword mapping");
LEXER_KEYWORDS(A)
#undef A


// Lexer interface
static int yylex(cpp2exp::parser::parser::semantic_type* yylval, cpp2exp::ASTContainer& container, cpp2exp::Lexer& lexer)
{
   // Get the next token
   cpp2exp::Lexer::TokenInfo info;
   auto token=lexer.next(info);

   // Construct a token node
   *yylval=new (container.allocateRaw(sizeof(cpp2exp::ast::Token))) cpp2exp::ast::Token(info.content, info.fromLine, info.fromColumn, info.toLine, info.toColumn);

   // And return the mapped token
   return (token == cpp2exp::Lexer::Token::Keyword) ? tokenTable[static_cast<unsigned>(info.keyword)+ static_cast<unsigned>(cpp2exp::Lexer::Token::Keyword)] : tokenTable[static_cast<unsigned>(token)];
}

namespace cpp2exp {

const AST* Parser::parseImpl()
{
   Lexer lexer(errors);
   lexer.reset(content);

   parser::parser parser(astContainer, lexer);
   if (parser.parse()!=0) return nullptr;
   return astContainer.getResult();
}

}
